# # -*- coding: utf-8 -*-
# """GIS_FTL_STREAMLITAPP.ipynb

# Automatically generated by Colab.

# Original file is located at
#     https://colab.research.google.com/drive/1eTBl5EMKGm7xUVFf9_pF95wgJnKbmf2X
# """

# # from google.colab import drive
# # drive.mount('/content/drive')

# # !pip install geopandas
# # !pip install pandas
# # !pip install pandas
# # !pip install shapely
# # !pip install matplotlib
# # !pip install  rasterio
# # !pip install streamlit
# # !pip install rasterstats

# # --- Imports ---
import geopandas as gpd
import pandas as pd
import rasterio
from rasterstats import zonal_stats
from shapely import wkt
import matplotlib.pyplot as plt
import streamlit as st
import os

st.set_page_config(page_title="Khartoum Flood Dashboard", layout="wide")

# --- Load Khartoum boundary ---
try:
    sudan_gdf = gpd.read_file("data/Khartoum.shp").to_crs("EPSG:4326")
    khartoum_gdf = sudan_gdf[sudan_gdf['id'] == 'SDKH']
except Exception as e:
    st.error(f"‚ùå Error loading Khartoum shapefile: {e}")
    st.stop()

# --- Load buildings CSV ---
try:
    buildings_df = pd.read_csv("data/buildings.csv")
    st.subheader("üìç Sample Building Data")
    st.dataframe(buildings_df.head())
except Exception as e:
    st.error(f"‚ùå Error loading buildings CSV: {e}")
    st.stop()

# --- Parse WKT geometry ---
if 'geometry' in buildings_df.columns:
    try:
        buildings_df['geometry'] = buildings_df['geometry'].apply(wkt.loads)
        buildings_gdf = gpd.GeoDataFrame(buildings_df, geometry='geometry', crs='EPSG:4326')
    except Exception as e:
        st.error(f"‚ùå Error parsing WKT geometries: {e}")
        st.stop()
else:
    st.error("‚ùå 'geometry' column not found in buildings CSV.")
    st.stop()

# --- Clip buildings to Khartoum ---
try:
    buildings_in_khartoum = gpd.sjoin(buildings_gdf, khartoum_gdf, how='inner', predicate='intersects')
except Exception as e:
    st.error(f"‚ùå Error clipping buildings to Khartoum: {e}")
    st.stop()

# --- Efficient zonal stats function ---
def get_flooded_buildings_chunked(flood_path, buildings_gdf, chunk_size=50000):
    flooded_chunks = []
    buildings_gdf = buildings_gdf.to_crs("EPSG:4326")
    for i in range(0, len(buildings_gdf), chunk_size):
        chunk = buildings_gdf.iloc[i:i+chunk_size]
        try:
            stats = zonal_stats(chunk, flood_path, stats=["max"], nodata=0)
            flooded_idx = [i for i, s in enumerate(stats) if s and s.get("max") == 1]
            flooded_chunks.append(chunk.iloc[flooded_idx])
        except Exception as e:
            st.warning(f"‚ö†Ô∏è Zonal stats failed for chunk {i}: {e}")
    return pd.concat(flooded_chunks).to_crs("EPSG:4326") if flooded_chunks else gpd.GeoDataFrame(columns=buildings_gdf.columns)

# --- Load flood masks ---
flood_files = {
    2018: "data/FloodMask_2018.tif",
    2019: "data/FloodMask_2019.tif",
    2020: "data/FloodMask_2020.tif"
}

flooded_by_year = {}
for year, path in flood_files.items():
    if os.path.exists(path):
        try:
            flooded_by_year[year] = get_flooded_buildings_chunked(path, buildings_in_khartoum)
        except Exception as e:
            st.warning(f"‚ö†Ô∏è Error processing flood mask for {year}: {e}")
    else:
        st.warning(f"üìÅ Flood mask not found for {year}: {path}")

if not flooded_by_year:
    st.warning("‚ö†Ô∏è No flood data available.")
    st.stop()

# --- Streamlit UI ---
st.title("üåä Flood Impact on Buildings in Khartoum (2018‚Äì2020)")
year = st.selectbox("Select Year", sorted(flooded_by_year.keys()))
flooded = flooded_by_year[year]

st.write(f"üè† Buildings affected in {year}: **{len(flooded)}**")

fig, ax = plt.subplots(figsize=(10, 8))
khartoum_gdf.plot(ax=ax, edgecolor='black', facecolor='none')
buildings_in_khartoum.plot(ax=ax, color='gray', alpha=0.3, label='All Buildings')

# ‚úÖ Check for valid geometries before plotting flooded buildings
if not flooded.empty and flooded.geometry.notnull().all():
    flooded.plot(ax=ax, color='red', label='Flooded Buildings')
else:
    st.warning(f"‚ö†Ô∏è No flooded buildings to plot for {year}.")

ax.legend()
st.pyplot(fig)

# --- Optional download ---
st.download_button(
    label=f"Download Flooded Buildings ({year})",
    data=flooded.to_csv(index=False),
    file_name=f"flooded_buildings_{year}.csv",
    mime="text/csv"
)


# import geopandas as gpd
# import pandas as pd
# import rasterio
# from rasterstats import zonal_stats
# from shapely import wkt
# import matplotlib.pyplot as plt
# import streamlit as st
# import os
# from rasterio.plot import show

# # --- Load Khartoum boundary ---
# try:
#     sudan_gdf = gpd.read_file("data/Khartoum.shp").to_crs("EPSG:4326")
#     khartoum_gdf = sudan_gdf[sudan_gdf['id'] == 'SDKH']
# except Exception as e:
#     st.error(f"‚ùå Error loading Khartoum shapefile: {e}")
#     st.stop()

# # --- Load buildings CSV from Google Drive ---
# url = "https://drive.google.com/uc?id=1lgJB2uDqc8GutFgfO7gxJZm9DptVgphU"
# try:
#     buildings_df = pd.read_csv(url)
#     st.subheader("üìç Sample Building Data")
#     st.dataframe(buildings_df.head())
# except Exception as e:
#     st.error(f"‚ùå Error loading buildings CSV: {e}")
#     st.stop()

# # --- Parse WKT geometry ---
# if 'geometry' in buildings_df.columns:
#     try:
#         buildings_df['geometry'] = buildings_df['geometry'].apply(wkt.loads)
#         buildings_gdf = gpd.GeoDataFrame(buildings_df, geometry='geometry', crs='EPSG:4326')
#     except Exception as e:
#         st.error(f"‚ùå Error parsing WKT geometries: {e}")
#         st.stop()
# else:
#     st.error("‚ùå 'geometry' column not found in buildings CSV.")
#     st.stop()

# # --- Clip buildings to Khartoum ---
# try:
#     buildings_in_khartoum = gpd.sjoin(buildings_gdf, khartoum_gdf, how='inner', predicate='intersects')
# except Exception as e:
#     st.error(f"‚ùå Error clipping buildings to Khartoum: {e}")
#     st.stop()

# # --- Zonal stats with CRS alignment and debug logging ---
# def get_flooded_buildings_chunked(flood_path, buildings_gdf, chunk_size=50000):
#     flooded_chunks = []
#     try:
#         with rasterio.open(flood_path) as src:
#             raster_crs = src.crs
#             buildings_gdf = buildings_gdf.to_crs(raster_crs)
#             for i in range(0, len(buildings_gdf), chunk_size):
#                 chunk = buildings_gdf.iloc[i:i+chunk_size]
#                 stats = zonal_stats(chunk, flood_path, stats=["max"], nodata=0)
#                 if not stats:
#                     st.warning(f"‚ö†Ô∏è No stats returned for chunk {i}-{i+chunk_size}")
#                 flooded_idx = [i for i, s in enumerate(stats) if s and s.get("max") == 1]
#                 flooded_chunks.append(chunk.iloc[flooded_idx])
#     except Exception as e:
#         st.error(f"‚ùå Error in zonal stats: {e}")
#         return gpd.GeoDataFrame(columns=buildings_gdf.columns)
#     return pd.concat(flooded_chunks).to_crs("EPSG:4326") if flooded_chunks else gpd.GeoDataFrame(columns=buildings_gdf.columns)

# # --- Load flood masks and compute affected buildings ---
# flood_files = {
#     2018: "data/FloodMask_2018.tif",
#     2019: "data/FloodMask_2019.tif",
#     2020: "data/FloodMask_2020.tif"
# }

# flooded_by_year = {}
# for year, path in flood_files.items():
#     if os.path.exists(path):
#         flooded_by_year[year] = get_flooded_buildings_chunked(path, buildings_in_khartoum)
#     else:
#         st.warning(f"üìÅ Flood mask not found for {year}: {path}")

# # --- Streamlit UI ---
# st.title("üåä Flood Impact on Buildings in Khartoum (2018‚Äì2020)")

# if flooded_by_year:
#     year = st.selectbox("Select Year", sorted(flooded_by_year.keys()))
#     flooded = flooded_by_year.get(year)

#     if flooded is not None and not flooded.empty:
#         st.write(f"üè† Buildings affected in {year}: **{len(flooded)}**")

#         fig, ax = plt.subplots(figsize=(10, 8))

#         # Plot flood raster in blue
#         try:
#             with rasterio.open(flood_files[year]) as src:
#                 show(src, ax=ax, cmap='Blues', alpha=0.5)
#         except Exception as e:
#             st.warning(f"‚ö†Ô∏è Could not display flood raster: {e}")

#         # Plot vector layers
#         khartoum_gdf.plot(ax=ax, edgecolor='black', facecolor='none')
#         buildings_in_khartoum.plot(ax=ax, color='gray', alpha=0.3, label='All Buildings')
#         flooded.plot(ax=ax, color='red', label='Flooded Buildings')

#         ax.legend()
#         st.pyplot(fig)

#         st.download_button(
#             label=f"Download Flooded Buildings ({year})",
#             data=flooded.to_csv(index=False),
#             file_name=f"flooded_buildings_{year}.csv",
#             mime="text/csv"
#         )
#     else:
#         st.warning(f"No flooded buildings found for {year}.")
# else:
#     st.warning("No flood data available.")

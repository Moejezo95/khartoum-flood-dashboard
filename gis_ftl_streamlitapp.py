# -*- coding: utf-8 -*-
"""GIS_FTL_STREAMLITAPP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eTBl5EMKGm7xUVFf9_pF95wgJnKbmf2X
"""
import geopandas as gpd
import pandas as pd
import rasterio
from rasterstats import zonal_stats
from shapely import wkt
import matplotlib.pyplot as plt
import streamlit as st
import os
import numpy as np

st.set_page_config(page_title="Khartoum Flood Dashboard", layout="wide")

# --- Load Khartoum boundary ---
try:
    sudan_gdf = gpd.read_file("data/Khartoum.shp").to_crs("EPSG:4326")
    khartoum_gdf = sudan_gdf.copy()

except Exception as e:
    st.error(f"‚ùå Error loading Khartoum shapefile: {e}")
    st.stop()

# --- Load buildings CSV ---
try:
    buildings_df = pd.read_csv("data/buildings.csv", encoding='utf-8')
    st.subheader("üìç Sample Building Data")
    st.dataframe(buildings_df.head())
except Exception as e:
    st.error(f"‚ùå Error loading buildings CSV: {e}")
    st.stop()

# --- Parse and clean WKT geometry ---
if 'geometry' in buildings_df.columns:
    try:
        buildings_df['geometry'] = buildings_df['geometry'].astype(str).str.strip().str.replace('"', '')
        valid_wkt = buildings_df['geometry'].apply(lambda x: isinstance(x, str) and x.startswith(('POINT', 'POLYGON', 'MULTIPOLYGON')))
        buildings_df = buildings_df[valid_wkt].copy()
        buildings_df['geometry'] = buildings_df['geometry'].apply(wkt.loads)
        buildings_gdf = gpd.GeoDataFrame(buildings_df, geometry='geometry', crs='EPSG:4326')
    except Exception as e:
        st.error(f"‚ùå Error parsing WKT geometries: {e}")
        st.stop()
else:
    st.error("‚ùå 'geometry' column not found in buildings CSV.")
    st.stop()

# --- Clip buildings to Khartoum ---
try:
    buildings_in_khartoum = gpd.sjoin(buildings_gdf, khartoum_gdf, how='inner', predicate='intersects')
except Exception as e:
    st.error(f"‚ùå Error clipping buildings to Khartoum: {e}")
    st.stop()

# --- Efficient zonal stats function ---
def get_flooded_buildings_chunked(flood_path, buildings_gdf, chunk_size=50000):
    flooded_chunks = []
    buildings_gdf = buildings_gdf.to_crs("EPSG:4326")
    for i in range(0, len(buildings_gdf), chunk_size):
        chunk = buildings_gdf.iloc[i:i+chunk_size]
        try:
            stats = zonal_stats(chunk, flood_path, stats=["max"], nodata=0)
            flooded_idx = [i for i, s in enumerate(stats) if s and s.get("max") == 1]
            flooded_chunks.append(chunk.iloc[flooded_idx])
        except Exception as e:
            st.warning(f"‚ö†Ô∏è Zonal stats failed for chunk {i}: {e}")
    return pd.concat(flooded_chunks).to_crs("EPSG:4326") if flooded_chunks else gpd.GeoDataFrame(columns=buildings_gdf.columns)

# --- Load flood masks ---
flood_files = {
    2018: "data/FloodMask_2018.tif",
    2019: "data/FloodMask_2019.tif",
    2020: "data/FloodMask_2020.tif"
}

flooded_by_year = {}
for year, path in flood_files.items():
    if os.path.exists(path):
        try:
            flooded_by_year[year] = get_flooded_buildings_chunked(path, buildings_in_khartoum)
        except Exception as e:
            st.warning(f"‚ö†Ô∏è Error processing flood mask for {year}: {e}")
    else:
        st.warning(f"üìÅ Flood mask not found for {year}: {path}")

if not flooded_by_year:
    st.warning("‚ö†Ô∏è No flood data available.")
    st.stop()

# --- Raster plotting helper ---
def plot_flood_raster(ax, raster_path):
    try:
        with rasterio.open(raster_path) as src:
            flood_data = src.read(1)
            flood_data = np.ma.masked_where(flood_data == 0, flood_data)
            extent = [src.bounds.left, src.bounds.right, src.bounds.bottom, src.bounds.top]
            ax.imshow(flood_data, extent=extent, cmap='Blues', alpha=0.5)
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Could not plot flood raster: {e}")

# --- Streamlit UI ---
st.title("üåä Flood Impact on Buildings in Khartoum (2018‚Äì2020)")
year = st.selectbox("Select Year", sorted(flooded_by_year.keys()))
flooded = flooded_by_year[year]

st.write(f"üè† Buildings affected in {year}: **{len(flooded)}**")
st.write(f"üîç Buildings in Khartoum: {len(buildings_in_khartoum)}")
st.write("üìê Geometry types:", buildings_in_khartoum.geometry.geom_type.unique())
st.write("üìè Average area:", buildings_in_khartoum.geometry.area.mean())
st.write("üñºÔ∏è Starting plot generation...")

# --- View toggle ---
view_mode = st.radio("üó∫Ô∏è Select Building View Mode", ["Polygons", "Centroids"])
# ploting the graph
fig, ax = plt.subplots(figsize=(10, 8))
fig.patch.set_facecolor('#f9f9f9')

# Plot Khartoum boundary
khartoum_gdf.plot(ax=ax, edgecolor='gray', facecolor='none', linewidth=1)

# Plot flood raster
plot_flood_raster(ax, flood_files[year])

# Plot buildings
buildings_in_khartoum.plot(
    ax=ax,
    color='#27ae60',
    edgecolor='black',
    linewidth=0.3,
    alpha=1.0,
    label='All Buildings'
)

# Plot flooded buildings
if not flooded.empty and flooded.geometry.notnull().all():
    flooded.plot(
        ax=ax,
        color='red',
        edgecolor='black',
        linewidth=0.3,
        label='Flooded Buildings'
    )

ax.set_title(f"Flood Impact in {year}", fontsize=16)
ax.axis('off')
ax.legend()
st.pyplot(fig)



# --- Optional download ---
st.download_button(
    label=f"Download Flooded Buildings ({year})",
    data=flooded.to_csv(index=False),
    file_name=f"flooded_buildings_{year}.csv",
    mime="text/csv"
)
